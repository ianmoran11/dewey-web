import type { CallbackUserFunction, QueryKey, RawResultData, Sqlite3Method, ScalarUserFunction, Statement, DatabaseInfo, ClientConfig, StatementInput, Transaction, DatabasePath, AggregateUserFunction, ReactiveQuery, SqlTag } from './types.js';
import type { BatchMessage, BroadcastMessage, DeleteMessage, DestroyMessage, ExportMessage, FunctionMessage, GetInfoMessage, ImportMessage, OmitQueryKey, OutputMessage, QueryMessage, TransactionMessage, WorkerProxy } from './messages.js';
import { SQLocalProcessor } from './processor.js';
export declare class SQLocal {
    protected config: ClientConfig;
    protected clientKey: QueryKey;
    protected processor: SQLocalProcessor | Worker;
    protected isDestroyed: boolean;
    protected bypassMutationLock: boolean;
    protected transactionQueryKeyQueue: QueryKey[];
    protected userCallbacks: Map<string, (...args: any[]) => void>;
    protected queriesInProgress: Map<string, [resolve: (message: OutputMessage) => void, reject: (error: unknown) => void]>;
    protected proxy: WorkerProxy;
    protected reinitChannel: BroadcastChannel;
    protected effectsChannel?: BroadcastChannel;
    constructor(databasePath: DatabasePath);
    constructor(config: ClientConfig);
    protected processMessageEvent: (event: OutputMessage | MessageEvent<OutputMessage>) => void;
    protected createQuery: (message: OmitQueryKey<QueryMessage | BatchMessage | TransactionMessage | FunctionMessage | GetInfoMessage | ImportMessage | ExportMessage | DeleteMessage | DestroyMessage>) => Promise<OutputMessage>;
    protected broadcast: (message: BroadcastMessage) => void;
    protected exec: (sql: string, params: unknown[], method?: Sqlite3Method, transactionKey?: QueryKey) => Promise<RawResultData>;
    protected execBatch: (statements: Statement[]) => Promise<RawResultData[]>;
    sql: <Result extends Record<string, any>>(queryTemplate: TemplateStringsArray | string, ...params: unknown[]) => Promise<Result[]>;
    batch: <Result extends Record<string, any>>(passStatements: (sql: SqlTag) => Statement[]) => Promise<Result[][]>;
    beginTransaction: () => Promise<Transaction>;
    transaction: <Result>(transaction: (tx: {
        sql: Transaction["sql"];
        query: Transaction["query"];
    }) => Promise<Result>) => Promise<Result>;
    reactiveQuery: <Result extends Record<string, any>>(passStatement: StatementInput<Result>) => ReactiveQuery<Result>;
    createCallbackFunction: (funcName: string, func: CallbackUserFunction["func"]) => Promise<void>;
    createScalarFunction: (funcName: string, func: ScalarUserFunction["func"]) => Promise<void>;
    createAggregateFunction: (funcName: string, func: AggregateUserFunction["func"]) => Promise<void>;
    getDatabaseInfo: () => Promise<DatabaseInfo>;
    getDatabaseFile: () => Promise<File>;
    overwriteDatabaseFile: (databaseFile: File | Blob | ArrayBuffer | Uint8Array<ArrayBuffer> | ReadableStream<Uint8Array<ArrayBuffer>>, beforeUnlock?: () => void | Promise<void>) => Promise<void>;
    deleteDatabaseFile: (beforeUnlock?: () => void | Promise<void>) => Promise<void>;
    destroy: () => Promise<void>;
    [Symbol.dispose]: () => void;
    [Symbol.asyncDispose]: () => Promise<void>;
}
